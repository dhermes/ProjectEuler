#!/usr/bin/env python

# LAGRANGE POLYNOMIAL FOR F:
# For data points (x_1, f(x_1))...(x_n, f(x_n))
# We have Lagrange base polynomials
# l_i(x) = prod_{j neq i} (x - x_j)/(x_i - x_j)
# L(x) = sum_i f(x_i) l_i(x)

# For our problem, we seek OP(n, n + 1), but this is
# L_n(n + 1) for L_n generated by the first n points
# x_i = i, with f given as 1 - n + n^2 ...

# If OP(n, n + 1) != f(n + 1), then we count the value
# We stop when n = 11

# f(x)(1 + x) = 1 + x^11

# We have L_n(n + 1) = sum_i f(i) l_i(n + 1)

import operator

from python.decorators import euler_timer


def lagrange(input_val, index, points):
    numerator = reduce(operator.mul, [input_val - points[i] for i in
                                      range(len(points)) if i != index])
    denominator = reduce(operator.mul, [points[index] - points[i] for i in
                                        range(len(points)) if i != index])
    return numerator * 1.0 / denominator


def n_value_approximation(func, n, input_val):
    if n == 1:
        return func(1)
    points = range(1, n + 1)
    return sum(func(points[i]) * lagrange(input_val, i, points)
               for i in range(len(points)))


def main(verbose=False):
    def func(x):
        return ((1 + x ** 11) * (1.0)) / (1 + x)
    result = 0
    for k in range(1, 11):
        val = n_value_approximation(func, k, k + 1)
        if val != func(k + 1):
            result += val
    return int(result)

if __name__ == '__main__':
    print euler_timer(101)(main)(verbose=True)
